{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Congress knowledge base. Right now these docs cover three open source projects: cyb - pure web3 browser cyb.ai chaingear - the consensus computer driven database framework chaingear.io cyberd - knowledge consensus computer in Go cyberd.ai congress - community of scientists, developers, engineers and craftsmen cybercongress.ai","title":"cyber\u2022Congress"},{"location":"contribute/","text":"Current wiki is built on top of mkdocs.org engine with Material for MkDocs extensions pack. Required Installations \u00b6 https://hub.docker.com/r/squidfunk/mkdocs-material/ Commands Cheat Sheet \u00b6 docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material docker run --rm -it -v ${PWD}:/docs squidfunk/mkdocs-material build docker run --rm -it -v ~/.ssh:/root/.ssh -v ${PWD}:/docs squidfunk/mkdocs-material gh-deploy Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Contributing"},{"location":"contribute/#required-installations","text":"https://hub.docker.com/r/squidfunk/mkdocs-material/","title":"Required Installations"},{"location":"contribute/#commands-cheat-sheet","text":"docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material docker run --rm -it -v ${PWD}:/docs squidfunk/mkdocs-material build docker run --rm -it -v ~/.ssh:/root/.ssh -v ${PWD}:/docs squidfunk/mkdocs-material gh-deploy","title":"Commands Cheat Sheet"},{"location":"contribute/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cyb/app-guidelines/","text":"DApp guidelines \u00b6 @asadovka What is App? \u00b6 App in Cyb is a one or multi page application. It can be a simple html file as a frontend and may include smart contract logic as a backend. Apps should be available through IPFS hash. App structure \u00b6 Cyb CLI can automatically generate structure for your App. All you need to do is just type some commands, come up with a name and develop! App requirements \u00b6 We set limitations of computation resources usage for each app. less then 5% of CPU usage less then 10% of RAM usage App development \u00b6 Here we describe how to generate initial app structure. Install the latest version of CYB package npm install -g cyb Select the path where you want to store your app. For example /Desktop/My_apps cd username/Desktop/My_apps Enter the name and generate the structure of the app. A folder with all necessary components will be created cyb init appname Go to the app folder and link your app with your Cyb cyb link Open the Appstore in CYB. You will see your app on \u00abYour app\u00bb page You can also use our Help App (cyb://.help/create) for more info. App deployment \u00b6 When you are ready with development of your app you can easely publish it to the DApp Store so every user of Cyb will see it. Open your app, click on \"deploy\" button and enter IPFS hash of your app. Sign the transaction - your app will be registred in Chaingear. And that is it! App design \u00b6 App design process follows Web3 design principles. State rules \u00b6 We use simple colored states for states of transactions or operations: mempool/failed - red confirmed/reverted - yellow finalized/succesful - green Data visualization \u00b6 Data should be visualised in a simple and attractive way. No overloaded plots an diagrams, we use animation instead. Blockchain objects presenting \u00b6 Blockchain data is too complicated and sometimes not obvious for people. Thus we use adaptive tricks to make work process more convenient: Logical grouping for objects. Every app page has common groups of data (general, blockchain specific) for inheritance of views and better navigation or data observing. Classical accounting terms used for balance and cashflow operations. Blockahains use econimic principles for interaction between subjects thus we can describe such processes in established terms. Robohash logo for contracts entities. Contracts can act by themself, have and algorithms, so it's more natural to perceive them like robots instead of pieces of code.","title":"App guidelines"},{"location":"cyb/app-guidelines/#dapp-guidelines","text":"@asadovka","title":"DApp guidelines"},{"location":"cyb/app-guidelines/#what-is-app","text":"App in Cyb is a one or multi page application. It can be a simple html file as a frontend and may include smart contract logic as a backend. Apps should be available through IPFS hash.","title":"What is App?"},{"location":"cyb/app-guidelines/#app-structure","text":"Cyb CLI can automatically generate structure for your App. All you need to do is just type some commands, come up with a name and develop!","title":"App structure"},{"location":"cyb/app-guidelines/#app-requirements","text":"We set limitations of computation resources usage for each app. less then 5% of CPU usage less then 10% of RAM usage","title":"App requirements"},{"location":"cyb/app-guidelines/#app-development","text":"Here we describe how to generate initial app structure. Install the latest version of CYB package npm install -g cyb Select the path where you want to store your app. For example /Desktop/My_apps cd username/Desktop/My_apps Enter the name and generate the structure of the app. A folder with all necessary components will be created cyb init appname Go to the app folder and link your app with your Cyb cyb link Open the Appstore in CYB. You will see your app on \u00abYour app\u00bb page You can also use our Help App (cyb://.help/create) for more info.","title":"App development"},{"location":"cyb/app-guidelines/#app-deployment","text":"When you are ready with development of your app you can easely publish it to the DApp Store so every user of Cyb will see it. Open your app, click on \"deploy\" button and enter IPFS hash of your app. Sign the transaction - your app will be registred in Chaingear. And that is it!","title":"App deployment"},{"location":"cyb/app-guidelines/#app-design","text":"App design process follows Web3 design principles.","title":"App design"},{"location":"cyb/app-guidelines/#state-rules","text":"We use simple colored states for states of transactions or operations: mempool/failed - red confirmed/reverted - yellow finalized/succesful - green","title":"State rules"},{"location":"cyb/app-guidelines/#data-visualization","text":"Data should be visualised in a simple and attractive way. No overloaded plots an diagrams, we use animation instead.","title":"Data visualization"},{"location":"cyb/app-guidelines/#blockchain-objects-presenting","text":"Blockchain data is too complicated and sometimes not obvious for people. Thus we use adaptive tricks to make work process more convenient: Logical grouping for objects. Every app page has common groups of data (general, blockchain specific) for inheritance of views and better navigation or data observing. Classical accounting terms used for balance and cashflow operations. Blockahains use econimic principles for interaction between subjects thus we can describe such processes in established terms. Robohash logo for contracts entities. Contracts can act by themself, have and algorithms, so it's more natural to perceive them like robots instead of pieces of code.","title":"Blockchain objects presenting"},{"location":"cyb/cyb/","text":"Cyb: web3 browser \u00b6 @xhipster @asadovka Concept. Definitions are work in progress. Current implementation is not in comply with spec yet Abstract \u00b6 Cyb is a friendly software robot who helps you explore the universes. Put it simply it just a web3 browser. At the very beginning Cyb is focusing on developers and advanced blockchain users who are able to work with private keys and transactions. But we see how Cyb becomes friendly for everyone who wants to interact with consensus computers in a web of the third generation. This new web is designed to free developers from outdated things such as html and v8. So developers can use any markup, execution and rendering engine they wish. That is why we don't focus on implementation of mentioned things. Instead this paper shows implementation agnostic concepts of browser that are simple enough to be adopted by web3 developers. Initially we design Cyb for conventional desktop browsing. But suggested concepts can be easily used for mobile, voice, VR and robotics implementations. Introduction \u00b6 Current state of web3 experience is non satisfactory. We still didn't meet any piece of software that is able to deliver deep and emotional web3 experience. So we decide to bring to the table one contender that strictly follows web3 principles defined by ourselves ;-) In a rush for this passion we define the following web3 apps which we believe together implement the full web3 vision in the context of a browsing for web3 agents and app developers: CLI \u00b6 Shell \u00b6 Here are the default UX elements, that Cyb uses to provide basic web3 UX: Navigation bar - search field, back & forward buttons App Bar - list of pinned favourites apps ID Bar - main identity data State Bar - node connection statuses .cyb \u00b6 Cyb has a lot of user and technical settings. They are implemented in the core browser app - .cyb: main.cyb : main page for every joe path.cyb : user's navigation history txq.cyb : user's transaction activity pins.cyb : pinned user's favourite apps and pages connect.cyb : connection manager root.cyb : cyb root registry help.cyb : cyb educational library and feedback mechanism dev.cyb : web3 development tool with support of contracts keys.cyb : keystore interface sign.cyb : phishing resistant signer for messages and transactions with scheduler wallet.cyb : universal wallet feed.cyb : notification & feed app access.cyb : permission manager that respects agents' resources Apps \u00b6 Main apps for initial web3 experience .cyber : cyberd node manager and app for link chains + - apps.cyber : search appstore - .ipfs : ipfs node manager and agent experience .eth : ethereum node manager + ens resolver .chaingear : all the things chaingearable .wiki : wiki indexator All this apps are considered as core apps and are included in every Cyb distribution. Let us describe in details every app as a pure concept. .main \u00b6 Purpose of the main app is to make agent happier in a moment it returns for surfing and between experiences. Main page of the browser consists of three main elements: search bar: provides all search functions relevance bar: the most relevant cyberlinks for a particular agent footer: cyberlinks to ecosystem resources which are important for education and contribution .path \u00b6 Navigation bar in Cyb is based on the following elements: back button - returns user to the previous state of web3 agent search bar - provides direct access to certain state star button - allow users to pin cyberlinks forward button - brings user to the future state based on Cyb prediction Search bar is used to browse web3. With the help of DURA with knowledge of application involved ( . ) it can get content across different content addressing protocols such as IPFS, DAT, SWARM, and inside blockchains, tangles and DAGs thus forming heterogeneous environment of web3. In web3 vision doc we describe in details a concept of web3 browsing based on DURA specs. That is, in web3 appending \"dot\" works very different in comparison with web2. Dot is literally a search query to a particular app that also has a content address in heterogeneous network. All symbols after \"dot\" make a map with content address of an app in root registry, and all data before \"dot\" is a query parameter to an app. <illustration> For example: .help query will open Cyb help app. chaingear.help will open chaingear info page in the help app. Query without \"dot\" will be automatically redirected to search in cyberd (Note: queries without dot is synonym to <your-query>.cyber ). Empty query always leads to the main page. . query returns a root registry that is being used by default in Cyb. <api-definition> All cyberlinks that was requested by agent can be accessed using path app that is integral part of Cyb experience. .connect \u00b6 In web3 all data has the state, so it become easier to navigate through it and make agent experience better. To be sure that you are working with actual state Cyb needs to manage connection to web3 providers. Our purpose is to build web3 browser that is agnostic from addressing, identity and consensus protocols. But currently we use ipfs, parity-light and cyberd nodes to show off possible experience at early stage of web3 development without necessity to connect to web3 provider at all (be your own web3 provider) for basic needs such as popular static content surfing and simple transfers of tokens. <illustration> Cyb is hiding all complexities of web3 connections under one colorful indicator that range from green to red. Ideally it works like indicator of internet connection we all used to see in smartphones. Connection indicator cyberlinked to a connect app that is integral part of id bar. It gives an ability for an agent to understand status of connections and chose web3 providers. <api-definition> Ultimate purpose of connect is to remove necessity of agents to manually switch between networks. Agent do not need to think about switching across networks. It is a goal of app developers and browser vendors to define an approach that allow seamless interaction during web3 experience with all network magic happens underneath. Cyb is developing in a way that allow async interactions with several peer-to-peer networks in an app context. .keys \u00b6 Purpose of id bar is to enable the concept of identity. Using identity an agent is able to authenticate messages and sign transactions in web3. Cyb assumes that an agent interacting with web3 is using active identity, but offers ability to change id of a signed transaction during signing. Agent understand which id is active using identicon. Cyb computes unique and deterministic identicons for every id, but offer agent to set any identicon for local pleasure. Clicking on id bar allow agent to choose active identity from a keys app. <illustration> Keys app is inherent component of id bar and embedded in Cyb. This app allows to store cryptographic secrets. Think of it as lastpass you don't need to trust that is able to compute different addresses, one time passwords and signatures in the context of an app. The following convention is used for keys : id: String, chainId: Number keystore: Promise <String> mnemonic: String derivationPath?: Promise <String> otherAddresses: Array <String> privateKey: String publicKey: Promise <String> type: String subtype: String The following API is being used to programmatically interact with id bar: setDefaultId(addressIndex: Number): Promise <Boolean> sign(transactionObject: Object): Promise <String> signMessage(messageObject: Object): Promise <String> verifyMessage(verificationObject: Object): Promise <Boolean> .cyber \u00b6 It happens then agent knows some content address but have no idea in which network it can be retrieved as well as what app can deal with it. That is why Cyb has default integration with cyber [CYBER] protocol. Cyb append .cyber app for all request without a dot. .cyber is an app that has simple interface to cyberd, which returns prediction of related cyberlinks thus agent can get required resource directly through peer-to-peer network. Cyb has a setting of default search engine, thus an agent can plug a search she wants. <api-definition> .pins \u00b6 App bar is a place where user can quickly get access to most used web3 objects. User can pin such objects by clicking on button \"favourite\" on navigation bar and then it will appear in app bar. Cyberlink manager is an attached app that allow agents to group and tag pins. .sign \u00b6 .sign allows users to sign messages and transactions in a way that brings web3 experience to the whole new level. Browser use embedded app for signing transactions so user can be always sure that transaction details are valid. In a web2 there is no inherent mechanism to be sure that overlay of an app is produced by a browser and not an app itself. Cyb solves this problem deterministically generating background and sound of overlay window in a way that an underlying app cannot know the seed for generating desired sound and visual pattern. The user need to remember its unique pattern once to safely interacting with different apps including not so trusted. Another problem we are approach to solve with .sign is deferred transactions. Cyb has its own address for which an agent can delegate some rights. Using this API app developer can create a logic that allow create and execute complex sequences of transactions client side. Since inception of Ethereum we sign thousands of transactions and miss even more. That is why we believe this feature is critical for awesome web3 experience. .crr \u00b6 According to 3 rules of root registry every developer can deliver best possible experience for their agents. That is why we want to mix the best from every word in our worlds in our implementation of root registry. To bring better user experience about 3k of records will be cybersquatted to align interests of existing app developers and agents who look for a beautiful, simple and trustful experience. .crr is a potpourri of the most well known concepts consolidated under one namespace! Let me introduce what is included in the shake: programming languages : up to 200 names common programs : up to 100 names tokens : Up to 1k names top-level domains : up to 300 names top english words : up to 1k names utf symbols : up to 300 names Initially cyber\u2022Congress will own all this cybersquatted records. In order to improve probability of adoption of .crr cyber\u2022Congres will distribute this names to original app developers based on proof of dns mechanism. That is, names for programming languages, common programs, tokens and top-level domains will be distributed based on a proof of dns according to verified registry produced by cyber\u2022Congress. Top english words and utf symbols will be distributed using competitions, grants and awards produced by cyber\u2022Congress. Initially unregistered names in .crr will be distributed under flat fee for cyb root registry owner in Chaingear. We are going to start from 1 ETH for every name and will see will it be enough to protect from abusive squatting or not. It is possible that we will switch to auction form of distribution in a future. .cyb \u00b6 Extension over .crr . Added fields: logo, tagline, manifest, meta, code, crr. As result it become suitable to be an app store for browser. Appstore treats pinned apps as installed if at leas one permission is granted. .access \u00b6 Permission management is of paramount importance in the process of safe application distribution. We want to improve upon 3 critical aspects of permission management in web: app authentication resource management dynamic permissions App authentication is hard in web2. You need somehow know the origin and this is practically hard in a face of government level adversaries, than you must compute hash of received file and compare it with a file hash received from origin. Due to practical complexity nobody do that. In web3 if you know that address is correct authentication is done automagically. That is why browser can easily verify that permission is granted for expected app and not malicious. Resource management was not in place. In web2 all permission systems was primarily build around a concept of granting access to a particular data which browser has access to. While this approach find itself useful it just not enough to run any application from untrusted developers. Computing resources has fundamental value now, thus must be carefully managed and metered. In web3 its weird that any untrusted app can eat all resources of a machine in no time. Moreover, if an application is executed in a sandbox all we need to feel ourselves safe (in addition to authenticated permissions) is ensure that app do not eat more resources than expected. Libraries that help app developers to mine some proof-of-work algorithms using visitor machine become ubiquitous. Practically that means that in addition to shity ads web2 users will experience even more worse web experience: greedy, slow and battery consuming apps are coming. The answer to this upcoming problem in a browser permission system which is able to produce bounds on apps consumption of fundamental resources such as cpu, gpu, ram, storage and broadband. We believe that resource management must be in the core of web3 application engine. We are currently doing research on how that can be implemented: containerisation seems to be low hanging fruit that can be embedded right into web experience. Permission affordances . Current permission systems are static in a sense that browser provide limited set of predefined apis. Cookies, location, camera, microphone, sound and notifications: that is very limited set of things browsers can afford. Permissions of a third party developers are not native for a browsers either. Browser just don't care about what data with which apps agent want to share. We ask ourselves what if a browser can ask apps what kind of permissions they can provide thus exposing this permission system to any other apps? We believe this approach will allow web3 developers provide experience inaccessible for previous architectures. .feed \u00b6 Notification panel displaying all pending transactions and web3 events corresponding to certain account. Settings button leads to settings page where user can manage connection to IPFS, Ethereum and Cyber nodes (local or remote ways). .ipfs \u00b6 This app is a third party app developed by IPFS Shipyard. This is very basic app for interacting with ipfs. .eth \u00b6 Simple app which ger DURI requests and route requests to ethereum node (contracts, transactions and blocks). Else resolve ENS. .wallet \u00b6 We believe that transfer of tokens is very basic experience in a web3 thus want to provide embedded in browser wallet app as soon as possible. Thus we consider either to develop our own bicycle or partner with some 3d party wallet developer. .dev \u00b6 Developers experience is critical for the whole web3 adoption. This app helps to develop and publish web3 apps. .cg \u00b6 Chaingear is an app that help developers create ethereum based CRUD databases. We believe it will help developers to adopt web3 easier the same they MySQL helped to site developers in the very beginning of web. .help \u00b6 Help is a two way help application. Using this app cyb helps agents to use itself. Using .help agents help Cyb evolve. As an open source project we are welcome for contributions. Gitcoin is an excellent instrument that we use for delegating tasks for community a processing payments for completed ones. We have our vision of how to develop browser and what kind of features develop first. But we give an opportunity for community to decide and vote with tokens what kind of browser we need to see in near future. Our product Chaingear is also made for this. We use user's feedback to make products better. So we provide options for bug reporting and feedback leaving on every page. .settings \u00b6 Cyb settings Saga on privacy and anonymity \u00b6 ... On censorship resistance \u00b6 ...","title":"Whitepaper"},{"location":"cyb/cyb/#cyb-web3-browser","text":"@xhipster @asadovka Concept. Definitions are work in progress. Current implementation is not in comply with spec yet","title":"Cyb: web3 browser"},{"location":"cyb/cyb/#abstract","text":"Cyb is a friendly software robot who helps you explore the universes. Put it simply it just a web3 browser. At the very beginning Cyb is focusing on developers and advanced blockchain users who are able to work with private keys and transactions. But we see how Cyb becomes friendly for everyone who wants to interact with consensus computers in a web of the third generation. This new web is designed to free developers from outdated things such as html and v8. So developers can use any markup, execution and rendering engine they wish. That is why we don't focus on implementation of mentioned things. Instead this paper shows implementation agnostic concepts of browser that are simple enough to be adopted by web3 developers. Initially we design Cyb for conventional desktop browsing. But suggested concepts can be easily used for mobile, voice, VR and robotics implementations.","title":"Abstract"},{"location":"cyb/cyb/#introduction","text":"Current state of web3 experience is non satisfactory. We still didn't meet any piece of software that is able to deliver deep and emotional web3 experience. So we decide to bring to the table one contender that strictly follows web3 principles defined by ourselves ;-) In a rush for this passion we define the following web3 apps which we believe together implement the full web3 vision in the context of a browsing for web3 agents and app developers:","title":"Introduction"},{"location":"cyb/cyb/#cli","text":"","title":"CLI"},{"location":"cyb/cyb/#shell","text":"Here are the default UX elements, that Cyb uses to provide basic web3 UX: Navigation bar - search field, back & forward buttons App Bar - list of pinned favourites apps ID Bar - main identity data State Bar - node connection statuses","title":"Shell"},{"location":"cyb/cyb/#cyb","text":"Cyb has a lot of user and technical settings. They are implemented in the core browser app - .cyb: main.cyb : main page for every joe path.cyb : user's navigation history txq.cyb : user's transaction activity pins.cyb : pinned user's favourite apps and pages connect.cyb : connection manager root.cyb : cyb root registry help.cyb : cyb educational library and feedback mechanism dev.cyb : web3 development tool with support of contracts keys.cyb : keystore interface sign.cyb : phishing resistant signer for messages and transactions with scheduler wallet.cyb : universal wallet feed.cyb : notification & feed app access.cyb : permission manager that respects agents' resources","title":".cyb"},{"location":"cyb/cyb/#apps","text":"Main apps for initial web3 experience .cyber : cyberd node manager and app for link chains + - apps.cyber : search appstore - .ipfs : ipfs node manager and agent experience .eth : ethereum node manager + ens resolver .chaingear : all the things chaingearable .wiki : wiki indexator All this apps are considered as core apps and are included in every Cyb distribution. Let us describe in details every app as a pure concept.","title":"Apps"},{"location":"cyb/cyb/#main","text":"Purpose of the main app is to make agent happier in a moment it returns for surfing and between experiences. Main page of the browser consists of three main elements: search bar: provides all search functions relevance bar: the most relevant cyberlinks for a particular agent footer: cyberlinks to ecosystem resources which are important for education and contribution","title":".main"},{"location":"cyb/cyb/#path","text":"Navigation bar in Cyb is based on the following elements: back button - returns user to the previous state of web3 agent search bar - provides direct access to certain state star button - allow users to pin cyberlinks forward button - brings user to the future state based on Cyb prediction Search bar is used to browse web3. With the help of DURA with knowledge of application involved ( . ) it can get content across different content addressing protocols such as IPFS, DAT, SWARM, and inside blockchains, tangles and DAGs thus forming heterogeneous environment of web3. In web3 vision doc we describe in details a concept of web3 browsing based on DURA specs. That is, in web3 appending \"dot\" works very different in comparison with web2. Dot is literally a search query to a particular app that also has a content address in heterogeneous network. All symbols after \"dot\" make a map with content address of an app in root registry, and all data before \"dot\" is a query parameter to an app. <illustration> For example: .help query will open Cyb help app. chaingear.help will open chaingear info page in the help app. Query without \"dot\" will be automatically redirected to search in cyberd (Note: queries without dot is synonym to <your-query>.cyber ). Empty query always leads to the main page. . query returns a root registry that is being used by default in Cyb. <api-definition> All cyberlinks that was requested by agent can be accessed using path app that is integral part of Cyb experience.","title":".path"},{"location":"cyb/cyb/#connect","text":"In web3 all data has the state, so it become easier to navigate through it and make agent experience better. To be sure that you are working with actual state Cyb needs to manage connection to web3 providers. Our purpose is to build web3 browser that is agnostic from addressing, identity and consensus protocols. But currently we use ipfs, parity-light and cyberd nodes to show off possible experience at early stage of web3 development without necessity to connect to web3 provider at all (be your own web3 provider) for basic needs such as popular static content surfing and simple transfers of tokens. <illustration> Cyb is hiding all complexities of web3 connections under one colorful indicator that range from green to red. Ideally it works like indicator of internet connection we all used to see in smartphones. Connection indicator cyberlinked to a connect app that is integral part of id bar. It gives an ability for an agent to understand status of connections and chose web3 providers. <api-definition> Ultimate purpose of connect is to remove necessity of agents to manually switch between networks. Agent do not need to think about switching across networks. It is a goal of app developers and browser vendors to define an approach that allow seamless interaction during web3 experience with all network magic happens underneath. Cyb is developing in a way that allow async interactions with several peer-to-peer networks in an app context.","title":".connect"},{"location":"cyb/cyb/#keys","text":"Purpose of id bar is to enable the concept of identity. Using identity an agent is able to authenticate messages and sign transactions in web3. Cyb assumes that an agent interacting with web3 is using active identity, but offers ability to change id of a signed transaction during signing. Agent understand which id is active using identicon. Cyb computes unique and deterministic identicons for every id, but offer agent to set any identicon for local pleasure. Clicking on id bar allow agent to choose active identity from a keys app. <illustration> Keys app is inherent component of id bar and embedded in Cyb. This app allows to store cryptographic secrets. Think of it as lastpass you don't need to trust that is able to compute different addresses, one time passwords and signatures in the context of an app. The following convention is used for keys : id: String, chainId: Number keystore: Promise <String> mnemonic: String derivationPath?: Promise <String> otherAddresses: Array <String> privateKey: String publicKey: Promise <String> type: String subtype: String The following API is being used to programmatically interact with id bar: setDefaultId(addressIndex: Number): Promise <Boolean> sign(transactionObject: Object): Promise <String> signMessage(messageObject: Object): Promise <String> verifyMessage(verificationObject: Object): Promise <Boolean>","title":".keys"},{"location":"cyb/cyb/#cyber","text":"It happens then agent knows some content address but have no idea in which network it can be retrieved as well as what app can deal with it. That is why Cyb has default integration with cyber [CYBER] protocol. Cyb append .cyber app for all request without a dot. .cyber is an app that has simple interface to cyberd, which returns prediction of related cyberlinks thus agent can get required resource directly through peer-to-peer network. Cyb has a setting of default search engine, thus an agent can plug a search she wants. <api-definition>","title":".cyber"},{"location":"cyb/cyb/#pins","text":"App bar is a place where user can quickly get access to most used web3 objects. User can pin such objects by clicking on button \"favourite\" on navigation bar and then it will appear in app bar. Cyberlink manager is an attached app that allow agents to group and tag pins.","title":".pins"},{"location":"cyb/cyb/#sign","text":".sign allows users to sign messages and transactions in a way that brings web3 experience to the whole new level. Browser use embedded app for signing transactions so user can be always sure that transaction details are valid. In a web2 there is no inherent mechanism to be sure that overlay of an app is produced by a browser and not an app itself. Cyb solves this problem deterministically generating background and sound of overlay window in a way that an underlying app cannot know the seed for generating desired sound and visual pattern. The user need to remember its unique pattern once to safely interacting with different apps including not so trusted. Another problem we are approach to solve with .sign is deferred transactions. Cyb has its own address for which an agent can delegate some rights. Using this API app developer can create a logic that allow create and execute complex sequences of transactions client side. Since inception of Ethereum we sign thousands of transactions and miss even more. That is why we believe this feature is critical for awesome web3 experience.","title":".sign"},{"location":"cyb/cyb/#crr","text":"According to 3 rules of root registry every developer can deliver best possible experience for their agents. That is why we want to mix the best from every word in our worlds in our implementation of root registry. To bring better user experience about 3k of records will be cybersquatted to align interests of existing app developers and agents who look for a beautiful, simple and trustful experience. .crr is a potpourri of the most well known concepts consolidated under one namespace! Let me introduce what is included in the shake: programming languages : up to 200 names common programs : up to 100 names tokens : Up to 1k names top-level domains : up to 300 names top english words : up to 1k names utf symbols : up to 300 names Initially cyber\u2022Congress will own all this cybersquatted records. In order to improve probability of adoption of .crr cyber\u2022Congres will distribute this names to original app developers based on proof of dns mechanism. That is, names for programming languages, common programs, tokens and top-level domains will be distributed based on a proof of dns according to verified registry produced by cyber\u2022Congress. Top english words and utf symbols will be distributed using competitions, grants and awards produced by cyber\u2022Congress. Initially unregistered names in .crr will be distributed under flat fee for cyb root registry owner in Chaingear. We are going to start from 1 ETH for every name and will see will it be enough to protect from abusive squatting or not. It is possible that we will switch to auction form of distribution in a future.","title":".crr"},{"location":"cyb/cyb/#cyb_1","text":"Extension over .crr . Added fields: logo, tagline, manifest, meta, code, crr. As result it become suitable to be an app store for browser. Appstore treats pinned apps as installed if at leas one permission is granted.","title":".cyb"},{"location":"cyb/cyb/#access","text":"Permission management is of paramount importance in the process of safe application distribution. We want to improve upon 3 critical aspects of permission management in web: app authentication resource management dynamic permissions App authentication is hard in web2. You need somehow know the origin and this is practically hard in a face of government level adversaries, than you must compute hash of received file and compare it with a file hash received from origin. Due to practical complexity nobody do that. In web3 if you know that address is correct authentication is done automagically. That is why browser can easily verify that permission is granted for expected app and not malicious. Resource management was not in place. In web2 all permission systems was primarily build around a concept of granting access to a particular data which browser has access to. While this approach find itself useful it just not enough to run any application from untrusted developers. Computing resources has fundamental value now, thus must be carefully managed and metered. In web3 its weird that any untrusted app can eat all resources of a machine in no time. Moreover, if an application is executed in a sandbox all we need to feel ourselves safe (in addition to authenticated permissions) is ensure that app do not eat more resources than expected. Libraries that help app developers to mine some proof-of-work algorithms using visitor machine become ubiquitous. Practically that means that in addition to shity ads web2 users will experience even more worse web experience: greedy, slow and battery consuming apps are coming. The answer to this upcoming problem in a browser permission system which is able to produce bounds on apps consumption of fundamental resources such as cpu, gpu, ram, storage and broadband. We believe that resource management must be in the core of web3 application engine. We are currently doing research on how that can be implemented: containerisation seems to be low hanging fruit that can be embedded right into web experience. Permission affordances . Current permission systems are static in a sense that browser provide limited set of predefined apis. Cookies, location, camera, microphone, sound and notifications: that is very limited set of things browsers can afford. Permissions of a third party developers are not native for a browsers either. Browser just don't care about what data with which apps agent want to share. We ask ourselves what if a browser can ask apps what kind of permissions they can provide thus exposing this permission system to any other apps? We believe this approach will allow web3 developers provide experience inaccessible for previous architectures.","title":".access"},{"location":"cyb/cyb/#feed","text":"Notification panel displaying all pending transactions and web3 events corresponding to certain account. Settings button leads to settings page where user can manage connection to IPFS, Ethereum and Cyber nodes (local or remote ways).","title":".feed"},{"location":"cyb/cyb/#ipfs","text":"This app is a third party app developed by IPFS Shipyard. This is very basic app for interacting with ipfs.","title":".ipfs"},{"location":"cyb/cyb/#eth","text":"Simple app which ger DURI requests and route requests to ethereum node (contracts, transactions and blocks). Else resolve ENS.","title":".eth"},{"location":"cyb/cyb/#wallet","text":"We believe that transfer of tokens is very basic experience in a web3 thus want to provide embedded in browser wallet app as soon as possible. Thus we consider either to develop our own bicycle or partner with some 3d party wallet developer.","title":".wallet"},{"location":"cyb/cyb/#dev","text":"Developers experience is critical for the whole web3 adoption. This app helps to develop and publish web3 apps.","title":".dev"},{"location":"cyb/cyb/#cg","text":"Chaingear is an app that help developers create ethereum based CRUD databases. We believe it will help developers to adopt web3 easier the same they MySQL helped to site developers in the very beginning of web.","title":".cg"},{"location":"cyb/cyb/#help","text":"Help is a two way help application. Using this app cyb helps agents to use itself. Using .help agents help Cyb evolve. As an open source project we are welcome for contributions. Gitcoin is an excellent instrument that we use for delegating tasks for community a processing payments for completed ones. We have our vision of how to develop browser and what kind of features develop first. But we give an opportunity for community to decide and vote with tokens what kind of browser we need to see in near future. Our product Chaingear is also made for this. We use user's feedback to make products better. So we provide options for bug reporting and feedback leaving on every page.","title":".help"},{"location":"cyb/cyb/#settings","text":"Cyb settings","title":".settings"},{"location":"cyb/cyb/#saga-on-privacy-and-anonymity","text":"...","title":"Saga on privacy and anonymity"},{"location":"cyb/cyb/#on-censorship-resistance","text":"...","title":"On censorship resistance"},{"location":"cyb/web3-vision/","text":"DURA: a missing piece for web3 \u00b6 @xhipster cyberCongress Early draft for web3 summit. Looking for a feedback . Abstract \u00b6 Originally an idea of web3 was inspired by Gavin Wood in 2014. A vision of Gavin was around 4 implementable concepts: content addressing, cryptographic identities, consensus computing and browsers. In parallel an idea of Interplanetary File System has been developed by Juan Benet. IPFS creates a foundation for web3: a system of content addressing and cryptographic identities. Since 2014 consensus computing has suffered insanely rapid development so one more missing piece is also in place. Still missing piece is a web3 browsing. Some projects such as Metamask has demonstrated a taste of web3. But one critical component in terms of browsing is just not there. URL scheme is outdated in terms of desired web3 properties and needs a drop in replacement. In this paper firstly we discuss necessary properties that we expect from web3. Based on this analysis we propose DURA scheme aka Distributed Unified Resource Address as drop in replacement for URLs that is being implemented in web3 browser Cyb . We believe DURA is a dump enough scheme (your captain) which can bring up basic consensus across web3 browser vendors due to simplicity, openness and protocol agnostic approach. Introduction \u00b6 Conventional protocols of the Internet such as TCP/IP, DNS, HTTPS and URL brought a web into the point there it is now. Along with all benefits they has created this protocols brought more problem into the table. Globality being a key property of the the web since inception is under real threat. Speed of connections degrade with network growth and from ubiquitous government interventions into privacy and security of web users. One property, not obvious in the beginning, become really important with everyday usage of the Internet: its ability to exchange permanent hyperlinks thus they would not break after time have pass. Reliance on one at a time internet service provider architecture allow governments censor packets. This fact is the last straw in conventional web stack for every engineer who is concerned about the future of our children. Other properties while being not so critical are very desirable: offline and real-time. Average internet user being offline must have ability to work with the state it has and after acquiring connection being able to sync with global state and continue verify state's validity in realtime while having connection. Now this properties offered on app level while such properties must be integrated into lower level protocols: into very core of web3. Speed \u00b6 Usability researches state that interactions that do not make sense in 100 milliseconds are considered as slow by an agent. Achieving such instant speeds is nearly impossible in the current stack of protocols. The following generation of the web must enable instant responses user requests. Necessity for lookup a location of resource using remote machine is an obvious bottleneck for reaching desired properties. Globality \u00b6 Current internet is starting to split into regions mutually inaccessible for each other. China is de facto such a region. Some countries are very close to joining the club. It is of paramount importance that web3 would remain global even in the face of government level adversaries. Security \u00b6 Current web applications are still in its infancy in term of permission abilities. Security of web apps is a very complicated topic. But one thing is obvious: it is hard to setup a secure system with third party apps without built in authentication system of the code being run on client machine. Current system of mutable resource location based on certificate authorities can not be safe by design. Permanent \u00b6 We are all experience broken links. IPFS has immunity to this issue. As long as you keep a file anybody can access it using globally defined immutable in time address of this file computed from the file itself. Mesh ready \u00b6 Current internet paradigm is based on 1 internet provider paradigm. That is basically a bad shit, because in general even if you have 2 or more internet connection like wifi and lte your device and/or operation system don't allow you to get the full possibilities of connectivity enforcing you to use only one connection at a time. Another major bad shit in current internet architecture is that your device is treated as leech by default. Every device keeps data necessary to being useful for surround devices. Huge portion of our network traffic goes not from origin server but from ISP cache. That means that changing a paradigm we can get to very different topology where our neighbors are our web3 providers. Verifiability \u00b6 ... Privacy and Anonymity \u00b6 ... Offline \u00b6 ... Realtime \u00b6 ... Roles \u00b6 In a web of the third generation roles are not like in a web2. There is no clear split on users, internet providers and sites. Key difference is such that interactions can happen truly peer to peer the one can be sovereign enough to be their own internet. Apps. Any content hash can be an app if it is known how to parse it. Agents. An app can become an agent if she can prove that she exist by digital signature. Providers. Any agent that is able to serve content can be web3 provider. Content addresses \u00b6 To understand why they so important we need to understand a difference in foundational concept of web2 and web3. Web2: Where => What-How : You must know resource location on a particular server to retrieve it. Web3: What => How : Instead of location based paradigm web3 is based on the content addressing paradigm. Key point is that we do not need to have knowledge of resource location in order to link to an object. In a web3 the answer to the How is either local or blockchain based registry with simple map between input address and address of an app. Cryptographic identities \u00b6 ... Consensus computers \u00b6 There are some very exhaustive articles around the topic of web3 which are really about consensus computing part of it. Worth to note that saying that any particular blockchain or even all blockchains altogether is web3 is like saying that databases is world wide web. Yes databases technology contributed to a development of www, but without several protocols this databases would not become interconnected through billions of web sites. Remember that in order to implement a vision of full web3 potential we need to find drop in replacement for every piece of current protocol stack: IP, TCP, HTTPS, DNS and URL. None of currently deployed blockchain technologies don't have necessary properties to directly replace dinosaurs. I would say that distributed ledger technology is a better database stack for the upcoming web. DURA scheme \u00b6 Distributed Unified Resource Address or put simply DURA is a more simpler and trustful scheme that has been used in a conventional web. It doesn't requires central authorities such as ICANN or others: [protocol]://[query].[root-app]/[navigation] We believe that a term cyberlink can be used for DURA links in order to differentiate with hyperlinks of previous internet architecture. Protocol \u00b6 dura:// It is a local handler that every os can handle. Being fully optional it can be very important in the very beginning of web3. Query \u00b6 dura://QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa If a browser is able to understand in which network she can resolve this particular content hash it can resolve it without much ado. Though we expect that IPFS will be not the only system and it become practically hard to say with 100% certainty whether given hash is ipfs hash or swarm or torrent or some other address type. That is there the concept of a root registry came into the game. In some sense it serves as an alternative to a self describing scheme used in CIDs. In some sense its not as it offer visually more sound links for agents. We believe that the root registry and self description concepts are complementary to each other. Root registry \u00b6 Current state of DNS root management is outdated. The most bad thing is that we still must to trust the most important things in our lives to strange organizations such as ICANN, IANA. We can ask ourselves why after 40 years of ubiquitous computer movement we still don't have simple common knowledge about what file extensions must be used with what software? Our proposal is a concept of a root register. Structure of root register is a simple map between short name and ipfs hash of a program that is being triggered: com:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa io:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa exe:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa pdf:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa eth:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa A name must be letter, number or hypen. Purpose of a root register is to reach some very basic os and network agnostic agreement about what extensions with what programs must be used. Of course the problem with such registry is that it must be somehow and somewhere maintained. Three rules of a root registry \u00b6 Software vendors must compete for a better root registry. Software vendors must add setting with a change of a root registry. Agents of browsers and operation systems must have ability to overwrite maps for local pleasure. One of the implementation is a cyb root registry Root registry app \u00b6 cyb://QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa.ipfs This is an example of full DURA link that is able get hash of ipfs app in a root registry, than throw predicate into this app and get a desired resource from a peer to peer network. Note: need to add real case of ipfs DURA app being used in Cyb. Note: need to add real case on how web2 link can be resolved using DURA approach. App navigation \u00b6 Traditionally its up to developers how to structure navigation within an app. But we believe that some scheme will be invented to differentiate statefull and stateless links as it is very important for DURA extensions \u00b6 A lot of cool stuff can be implemented using extensions. Extension is any symbol that adds predictable an logical behavior for parsing and rendering of requests. Examples: - local paths - connection links - URL parameters Key principle is that semantics is programmable and can be delivered from a distributed network using symbols that has been registered in a root registry. Where extension \u00b6 Keyword: - / before content address is a local path Examples: /users/xhipster/cybernode.ai /ethereum/cybersearch.eth Linkchain extension \u00b6 Keyword: - @ between DURA statements Examples: xhipster.eth@cybercongress.ai Need to find cyberlinks between two cyberlinks. Reference \u00b6 ...","title":"Web3 vision"},{"location":"cyb/web3-vision/#dura-a-missing-piece-for-web3","text":"@xhipster cyberCongress Early draft for web3 summit. Looking for a feedback .","title":"DURA: a missing piece for web3"},{"location":"cyb/web3-vision/#abstract","text":"Originally an idea of web3 was inspired by Gavin Wood in 2014. A vision of Gavin was around 4 implementable concepts: content addressing, cryptographic identities, consensus computing and browsers. In parallel an idea of Interplanetary File System has been developed by Juan Benet. IPFS creates a foundation for web3: a system of content addressing and cryptographic identities. Since 2014 consensus computing has suffered insanely rapid development so one more missing piece is also in place. Still missing piece is a web3 browsing. Some projects such as Metamask has demonstrated a taste of web3. But one critical component in terms of browsing is just not there. URL scheme is outdated in terms of desired web3 properties and needs a drop in replacement. In this paper firstly we discuss necessary properties that we expect from web3. Based on this analysis we propose DURA scheme aka Distributed Unified Resource Address as drop in replacement for URLs that is being implemented in web3 browser Cyb . We believe DURA is a dump enough scheme (your captain) which can bring up basic consensus across web3 browser vendors due to simplicity, openness and protocol agnostic approach.","title":"Abstract"},{"location":"cyb/web3-vision/#introduction","text":"Conventional protocols of the Internet such as TCP/IP, DNS, HTTPS and URL brought a web into the point there it is now. Along with all benefits they has created this protocols brought more problem into the table. Globality being a key property of the the web since inception is under real threat. Speed of connections degrade with network growth and from ubiquitous government interventions into privacy and security of web users. One property, not obvious in the beginning, become really important with everyday usage of the Internet: its ability to exchange permanent hyperlinks thus they would not break after time have pass. Reliance on one at a time internet service provider architecture allow governments censor packets. This fact is the last straw in conventional web stack for every engineer who is concerned about the future of our children. Other properties while being not so critical are very desirable: offline and real-time. Average internet user being offline must have ability to work with the state it has and after acquiring connection being able to sync with global state and continue verify state's validity in realtime while having connection. Now this properties offered on app level while such properties must be integrated into lower level protocols: into very core of web3.","title":"Introduction"},{"location":"cyb/web3-vision/#speed","text":"Usability researches state that interactions that do not make sense in 100 milliseconds are considered as slow by an agent. Achieving such instant speeds is nearly impossible in the current stack of protocols. The following generation of the web must enable instant responses user requests. Necessity for lookup a location of resource using remote machine is an obvious bottleneck for reaching desired properties.","title":"Speed"},{"location":"cyb/web3-vision/#globality","text":"Current internet is starting to split into regions mutually inaccessible for each other. China is de facto such a region. Some countries are very close to joining the club. It is of paramount importance that web3 would remain global even in the face of government level adversaries.","title":"Globality"},{"location":"cyb/web3-vision/#security","text":"Current web applications are still in its infancy in term of permission abilities. Security of web apps is a very complicated topic. But one thing is obvious: it is hard to setup a secure system with third party apps without built in authentication system of the code being run on client machine. Current system of mutable resource location based on certificate authorities can not be safe by design.","title":"Security"},{"location":"cyb/web3-vision/#permanent","text":"We are all experience broken links. IPFS has immunity to this issue. As long as you keep a file anybody can access it using globally defined immutable in time address of this file computed from the file itself.","title":"Permanent"},{"location":"cyb/web3-vision/#mesh-ready","text":"Current internet paradigm is based on 1 internet provider paradigm. That is basically a bad shit, because in general even if you have 2 or more internet connection like wifi and lte your device and/or operation system don't allow you to get the full possibilities of connectivity enforcing you to use only one connection at a time. Another major bad shit in current internet architecture is that your device is treated as leech by default. Every device keeps data necessary to being useful for surround devices. Huge portion of our network traffic goes not from origin server but from ISP cache. That means that changing a paradigm we can get to very different topology where our neighbors are our web3 providers.","title":"Mesh ready"},{"location":"cyb/web3-vision/#verifiability","text":"...","title":"Verifiability"},{"location":"cyb/web3-vision/#privacy-and-anonymity","text":"...","title":"Privacy and Anonymity"},{"location":"cyb/web3-vision/#offline","text":"...","title":"Offline"},{"location":"cyb/web3-vision/#realtime","text":"...","title":"Realtime"},{"location":"cyb/web3-vision/#roles","text":"In a web of the third generation roles are not like in a web2. There is no clear split on users, internet providers and sites. Key difference is such that interactions can happen truly peer to peer the one can be sovereign enough to be their own internet. Apps. Any content hash can be an app if it is known how to parse it. Agents. An app can become an agent if she can prove that she exist by digital signature. Providers. Any agent that is able to serve content can be web3 provider.","title":"Roles"},{"location":"cyb/web3-vision/#content-addresses","text":"To understand why they so important we need to understand a difference in foundational concept of web2 and web3. Web2: Where => What-How : You must know resource location on a particular server to retrieve it. Web3: What => How : Instead of location based paradigm web3 is based on the content addressing paradigm. Key point is that we do not need to have knowledge of resource location in order to link to an object. In a web3 the answer to the How is either local or blockchain based registry with simple map between input address and address of an app.","title":"Content addresses"},{"location":"cyb/web3-vision/#cryptographic-identities","text":"...","title":"Cryptographic identities"},{"location":"cyb/web3-vision/#consensus-computers","text":"There are some very exhaustive articles around the topic of web3 which are really about consensus computing part of it. Worth to note that saying that any particular blockchain or even all blockchains altogether is web3 is like saying that databases is world wide web. Yes databases technology contributed to a development of www, but without several protocols this databases would not become interconnected through billions of web sites. Remember that in order to implement a vision of full web3 potential we need to find drop in replacement for every piece of current protocol stack: IP, TCP, HTTPS, DNS and URL. None of currently deployed blockchain technologies don't have necessary properties to directly replace dinosaurs. I would say that distributed ledger technology is a better database stack for the upcoming web.","title":"Consensus computers"},{"location":"cyb/web3-vision/#dura-scheme","text":"Distributed Unified Resource Address or put simply DURA is a more simpler and trustful scheme that has been used in a conventional web. It doesn't requires central authorities such as ICANN or others: [protocol]://[query].[root-app]/[navigation] We believe that a term cyberlink can be used for DURA links in order to differentiate with hyperlinks of previous internet architecture.","title":"DURA scheme"},{"location":"cyb/web3-vision/#protocol","text":"dura:// It is a local handler that every os can handle. Being fully optional it can be very important in the very beginning of web3.","title":"Protocol"},{"location":"cyb/web3-vision/#query","text":"dura://QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa If a browser is able to understand in which network she can resolve this particular content hash it can resolve it without much ado. Though we expect that IPFS will be not the only system and it become practically hard to say with 100% certainty whether given hash is ipfs hash or swarm or torrent or some other address type. That is there the concept of a root registry came into the game. In some sense it serves as an alternative to a self describing scheme used in CIDs. In some sense its not as it offer visually more sound links for agents. We believe that the root registry and self description concepts are complementary to each other.","title":"Query"},{"location":"cyb/web3-vision/#root-registry","text":"Current state of DNS root management is outdated. The most bad thing is that we still must to trust the most important things in our lives to strange organizations such as ICANN, IANA. We can ask ourselves why after 40 years of ubiquitous computer movement we still don't have simple common knowledge about what file extensions must be used with what software? Our proposal is a concept of a root register. Structure of root register is a simple map between short name and ipfs hash of a program that is being triggered: com:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa io:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa exe:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa pdf:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa eth:QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa A name must be letter, number or hypen. Purpose of a root register is to reach some very basic os and network agnostic agreement about what extensions with what programs must be used. Of course the problem with such registry is that it must be somehow and somewhere maintained.","title":"Root registry"},{"location":"cyb/web3-vision/#three-rules-of-a-root-registry","text":"Software vendors must compete for a better root registry. Software vendors must add setting with a change of a root registry. Agents of browsers and operation systems must have ability to overwrite maps for local pleasure. One of the implementation is a cyb root registry","title":"Three rules of a root registry"},{"location":"cyb/web3-vision/#root-registry-app","text":"cyb://QmQLXHs7K98JNQdWrBB2cQLJahPhmupbDjRuH1b9ibmwVa.ipfs This is an example of full DURA link that is able get hash of ipfs app in a root registry, than throw predicate into this app and get a desired resource from a peer to peer network. Note: need to add real case of ipfs DURA app being used in Cyb. Note: need to add real case on how web2 link can be resolved using DURA approach.","title":"Root registry app"},{"location":"cyb/web3-vision/#app-navigation","text":"Traditionally its up to developers how to structure navigation within an app. But we believe that some scheme will be invented to differentiate statefull and stateless links as it is very important for","title":"App navigation"},{"location":"cyb/web3-vision/#dura-extensions","text":"A lot of cool stuff can be implemented using extensions. Extension is any symbol that adds predictable an logical behavior for parsing and rendering of requests. Examples: - local paths - connection links - URL parameters Key principle is that semantics is programmable and can be delivered from a distributed network using symbols that has been registered in a root registry.","title":"DURA extensions"},{"location":"cyb/web3-vision/#where-extension","text":"Keyword: - / before content address is a local path Examples: /users/xhipster/cybernode.ai /ethereum/cybersearch.eth","title":"Where extension"},{"location":"cyb/web3-vision/#linkchain-extension","text":"Keyword: - @ between DURA statements Examples: xhipster.eth@cybercongress.ai Need to find cyberlinks between two cyberlinks.","title":"Linkchain extension"},{"location":"cyb/web3-vision/#reference","text":"...","title":"Reference"},{"location":"cyberd/Changelog/","text":"","title":"Changelog"},{"location":"cyberd/Contributing/","text":"Contributing list \u00b6 @litvintech - contracts developer/maintainer @pechalka - web3 app developer/maintainer","title":"Contributing"},{"location":"cyberd/Contributing/#contributing-list","text":"@litvintech - contracts developer/maintainer @pechalka - web3 app developer/maintainer","title":"Contributing list"},{"location":"cyberd/contracts/","text":"Contracts Overview \u00b6 Design rationale \u00b6 Main design principle goes from ERC721 NFT tokenization of Databases (in Chaingear/Database of databases) and Entries (in custom user's Database). In reason of Databases tokenization in Chaingear which allows token holder acts as administrator of their Databases, Chaingear acts to Database as owner, which sets token holder as administrator on creation phase, changes administrator when holder transfers token to another user, and transfers ownership when user unregister Database in Chaingear, giving them full control to contract. Database deep-linked to Chaingear database token. In other words, token ownership means control of Database. Also, Chaingear supports multiple Database Builders (fabrics of databases of given type), and allows Chaingear owners provide different kind and versioning of Databases. In reason of providing user functionality to describe their custom database data structures/schema and CRUD operations, the user creates their custom smart-contract, which implements the ISchema interface. This contract acts as inner storage, defines schema, and Database acts them on token operations (creating and deleting). A user may deploy erroneous or vulnerable Schema contract, but this should not crash Chaingear-Database NFT-token logic and Database inner entry NFT-logic too. Even if this happens Database crashing should not affect Chaingear/metadatabase contract. We proceed from the premise that the creator of the database (administrator) is positive and it does not make sense for them to break his database by initializing it with an incorrect contract. This brings us to tokenized ( C RU D ) operations (and inner in Schema) in Database and public ( C R UD ) plus tokenized ( CR U D ) Storage operation. Chaingear inheritance \u00b6 Database inheritance \u00b6 /chaingear \u00b6 Chaingear allows any user to create his own database. Building fee is collecting by new database creation. All builded databases are tokenized with ERC721 NFT token standard and saved in Chaingear metadatabase with db metainformation. Creator of database may transfer tokenized ownership of database and destroy database with token burning. Tokenized databases Entries may collect funds by users and Database's owner may claim them. Chaingear supports multiple benefitiaries witch have access to collected fees from databases creation. Also allows for owner add multiple database builders contracts based their on versioning or/and functionality. /builders \u00b6 DatabaseBuilder contains the code of specified version of Database. This code used by Chaingear for Database creation and deploy process. DatabaseBuilder should be added with specified version and description to Chaingear database's builders inner list. Chaingear contract should be added as allowed caller to DatabaseBuilder with reason to allow creation calls only by Chaingear contact. /common \u00b6 Safe allows creator contract transfer ETHs to them and claim from, accounting logic holded by owner contract. IChaingear IDatabase IDatabaseBuilder ISchema /databases \u00b6 Database contract witch tokenize entries as NFT tokens via ERC721 standard. Users can create tokenized empty entries according to entry access policy setted in Database. Database provides tokenized ( C RU D ) actions, after creation of token and empty database object, user should initialize them ( CR U D ) in Storage. Also users can fund entries with ETHs which send to DatabaseSafe with which owner of entry token can claim funds. DatabaseAccessControl holds logic of controlling database and accessing to entries creation. Policy options to entries creation are OnlyAdministrator, Whitelist, AllUsers. Chaingear acts as owner of Database and creator of database acts of administrator with separated policies to Database functions. /schemas \u00b6 Schema partially code-generated contract where database creator setup their custom entry structure and setters/getters. Schema then initializes in Database by their creator (as admin) and completes Database setup process. Provides public ( C RU D ) actions for users and inner ( C RU D ) tokenized actions for Database. Database goes as owner of contract (and acts as proxy) with entries creating, token-based transferring and deleting. EntryInterface interface (should be implemented in user EntryCore contract) \u00b6 interface ISchema { function createEntry () external ; function deleteEntry ( uint256 ) external ; } Example Schema \u00b6 pragma solidity 0.4.25 ; import \"../common/ISchema.sol\" ; import \"../common/IDatabase.sol\" ; import \"openzeppelin-solidity/contracts/ownership/Ownable.sol\" ; import \"openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol\" ; contract Schema is ISchema , Ownable , SupportsInterfaceWithLookup { bytes4 constant internal INTERFACE_SCHEMA_ID = 0x153366ed ; struct Entry { string name ; string manifest ; string extension ; string content ; string logo ; } Entry [] public entries ; IDatabase internal database ; constructor () public { _registerInterface ( INTERFACE_SCHEMA_ID ); database = IDatabase ( owner ); } function () external {} function createEntry () external onlyOwner { Entry memory m = ( Entry ( { name : \"\" , manifest : \"\" , extension : \"\" , content : \"\" , logo : \"\" })); entries . push ( m ); } function readEntry ( uint256 _entryID ) external view returns ( string , string , string , string , string ) { uint256 entryIndex = database . getIndexByID ( _entryID ); return ( entries [ entryIndex ]. name , entries [ entryIndex ]. manifest , entries [ entryIndex ]. extension , entries [ entryIndex ]. content , entries [ entryIndex ]. logo ); } function updateEntry ( uint256 _entryID , string _name , string _manifest , string _extension , string _content , string _logo ) external { database . auth ( _entryID , msg . sender ); uint256 entryIndex = database . getIndexByID ( _entryID ); Entry memory m = ( Entry ( { name : _name , manifest : _manifest , extension : _extension , content : _content , logo : _logo })); entries [ entryIndex ] = m ; } function deleteEntry ( uint256 _entryIndex ) external onlyOwner { uint256 lastEntryIndex = entries . length - 1 ; Entry memory lastEntry = entries [ lastEntryIndex ]; entries [ _entryIndex ] = lastEntry ; delete entries [ lastEntryIndex ]; entries . length -- ; } }","title":"Contracts Overview"},{"location":"cyberd/contracts/#contracts-overview","text":"","title":"Contracts Overview"},{"location":"cyberd/contracts/#design-rationale","text":"Main design principle goes from ERC721 NFT tokenization of Databases (in Chaingear/Database of databases) and Entries (in custom user's Database). In reason of Databases tokenization in Chaingear which allows token holder acts as administrator of their Databases, Chaingear acts to Database as owner, which sets token holder as administrator on creation phase, changes administrator when holder transfers token to another user, and transfers ownership when user unregister Database in Chaingear, giving them full control to contract. Database deep-linked to Chaingear database token. In other words, token ownership means control of Database. Also, Chaingear supports multiple Database Builders (fabrics of databases of given type), and allows Chaingear owners provide different kind and versioning of Databases. In reason of providing user functionality to describe their custom database data structures/schema and CRUD operations, the user creates their custom smart-contract, which implements the ISchema interface. This contract acts as inner storage, defines schema, and Database acts them on token operations (creating and deleting). A user may deploy erroneous or vulnerable Schema contract, but this should not crash Chaingear-Database NFT-token logic and Database inner entry NFT-logic too. Even if this happens Database crashing should not affect Chaingear/metadatabase contract. We proceed from the premise that the creator of the database (administrator) is positive and it does not make sense for them to break his database by initializing it with an incorrect contract. This brings us to tokenized ( C RU D ) operations (and inner in Schema) in Database and public ( C R UD ) plus tokenized ( CR U D ) Storage operation.","title":"Design rationale"},{"location":"cyberd/contracts/#chaingear-inheritance","text":"","title":"Chaingear inheritance"},{"location":"cyberd/contracts/#database-inheritance","text":"","title":"Database inheritance"},{"location":"cyberd/contracts/#chaingear","text":"Chaingear allows any user to create his own database. Building fee is collecting by new database creation. All builded databases are tokenized with ERC721 NFT token standard and saved in Chaingear metadatabase with db metainformation. Creator of database may transfer tokenized ownership of database and destroy database with token burning. Tokenized databases Entries may collect funds by users and Database's owner may claim them. Chaingear supports multiple benefitiaries witch have access to collected fees from databases creation. Also allows for owner add multiple database builders contracts based their on versioning or/and functionality.","title":"/chaingear"},{"location":"cyberd/contracts/#builders","text":"DatabaseBuilder contains the code of specified version of Database. This code used by Chaingear for Database creation and deploy process. DatabaseBuilder should be added with specified version and description to Chaingear database's builders inner list. Chaingear contract should be added as allowed caller to DatabaseBuilder with reason to allow creation calls only by Chaingear contact.","title":"/builders"},{"location":"cyberd/contracts/#common","text":"Safe allows creator contract transfer ETHs to them and claim from, accounting logic holded by owner contract. IChaingear IDatabase IDatabaseBuilder ISchema","title":"/common"},{"location":"cyberd/contracts/#databases","text":"Database contract witch tokenize entries as NFT tokens via ERC721 standard. Users can create tokenized empty entries according to entry access policy setted in Database. Database provides tokenized ( C RU D ) actions, after creation of token and empty database object, user should initialize them ( CR U D ) in Storage. Also users can fund entries with ETHs which send to DatabaseSafe with which owner of entry token can claim funds. DatabaseAccessControl holds logic of controlling database and accessing to entries creation. Policy options to entries creation are OnlyAdministrator, Whitelist, AllUsers. Chaingear acts as owner of Database and creator of database acts of administrator with separated policies to Database functions.","title":"/databases"},{"location":"cyberd/contracts/#schemas","text":"Schema partially code-generated contract where database creator setup their custom entry structure and setters/getters. Schema then initializes in Database by their creator (as admin) and completes Database setup process. Provides public ( C RU D ) actions for users and inner ( C RU D ) tokenized actions for Database. Database goes as owner of contract (and acts as proxy) with entries creating, token-based transferring and deleting.","title":"/schemas"},{"location":"cyberd/contracts/#entryinterface-interface-should-be-implemented-in-user-entrycore-contract","text":"interface ISchema { function createEntry () external ; function deleteEntry ( uint256 ) external ; }","title":"EntryInterface interface (should be implemented in user EntryCore contract)"},{"location":"cyberd/contracts/#example-schema","text":"pragma solidity 0.4.25 ; import \"../common/ISchema.sol\" ; import \"../common/IDatabase.sol\" ; import \"openzeppelin-solidity/contracts/ownership/Ownable.sol\" ; import \"openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol\" ; contract Schema is ISchema , Ownable , SupportsInterfaceWithLookup { bytes4 constant internal INTERFACE_SCHEMA_ID = 0x153366ed ; struct Entry { string name ; string manifest ; string extension ; string content ; string logo ; } Entry [] public entries ; IDatabase internal database ; constructor () public { _registerInterface ( INTERFACE_SCHEMA_ID ); database = IDatabase ( owner ); } function () external {} function createEntry () external onlyOwner { Entry memory m = ( Entry ( { name : \"\" , manifest : \"\" , extension : \"\" , content : \"\" , logo : \"\" })); entries . push ( m ); } function readEntry ( uint256 _entryID ) external view returns ( string , string , string , string , string ) { uint256 entryIndex = database . getIndexByID ( _entryID ); return ( entries [ entryIndex ]. name , entries [ entryIndex ]. manifest , entries [ entryIndex ]. extension , entries [ entryIndex ]. content , entries [ entryIndex ]. logo ); } function updateEntry ( uint256 _entryID , string _name , string _manifest , string _extension , string _content , string _logo ) external { database . auth ( _entryID , msg . sender ); uint256 entryIndex = database . getIndexByID ( _entryID ); Entry memory m = ( Entry ( { name : _name , manifest : _manifest , extension : _extension , content : _content , logo : _logo })); entries [ entryIndex ] = m ; } function deleteEntry ( uint256 _entryIndex ) external onlyOwner { uint256 lastEntryIndex = entries . length - 1 ; Entry memory lastEntry = entries [ lastEntryIndex ]; entries [ _entryIndex ] = lastEntry ; delete entries [ lastEntryIndex ]; entries . length -- ; } }","title":"Example Schema"},{"location":"cyberd/overview/","text":"Overview \u00b6 This project allows you to create your own Database of general purpose entries on Ethereum blockchain. Entry type is defined during creation, so you can put into entry any custom logic you want (validation, entry-level permission control). Entries are tokenized as NFT. Your creating your database in Chaingear - metadatabase, which are one point of access to all databases. Databases on chaingear level are tokenized as NFT. Chaingear is most expensive database, so you should pay for your database and entry creation. Features \u00b6 Chaingear \u00b6 Metadatabase with Databases entries, where each entry are ERC721 token Fee-based Database creation Creating Databases with different functionality Token-based ownership/administration for Database Funding in ETH for Database Custom database \u00b6 Custom data structure for Database (Schema) Each Entry is ERC721 token Fee-based Entry creation Token-based ownership Entry management Entry creation policies (Administrator, Whitelist, AllUsers) Chaingear UI (browser/stand-alone web3 DApp) \u00b6 Web3/Metamask/Truffle/IPFS based Full Chaingear control interface Full custom Database control interface Schema smart-contract code generation and deploying on client Databases ABI and metainformation savings in IPFS","title":"Overview"},{"location":"cyberd/overview/#overview","text":"This project allows you to create your own Database of general purpose entries on Ethereum blockchain. Entry type is defined during creation, so you can put into entry any custom logic you want (validation, entry-level permission control). Entries are tokenized as NFT. Your creating your database in Chaingear - metadatabase, which are one point of access to all databases. Databases on chaingear level are tokenized as NFT. Chaingear is most expensive database, so you should pay for your database and entry creation.","title":"Overview"},{"location":"cyberd/overview/#features","text":"","title":"Features"},{"location":"cyberd/overview/#chaingear","text":"Metadatabase with Databases entries, where each entry are ERC721 token Fee-based Database creation Creating Databases with different functionality Token-based ownership/administration for Database Funding in ETH for Database","title":"Chaingear"},{"location":"cyberd/overview/#custom-database","text":"Custom data structure for Database (Schema) Each Entry is ERC721 token Fee-based Entry creation Token-based ownership Entry management Entry creation policies (Administrator, Whitelist, AllUsers)","title":"Custom database"},{"location":"cyberd/overview/#chaingear-ui-browserstand-alone-web3-dapp","text":"Web3/Metamask/Truffle/IPFS based Full Chaingear control interface Full custom Database control interface Schema smart-contract code generation and deploying on client Databases ABI and metainformation savings in IPFS","title":"Chaingear UI (browser/stand-alone web3 DApp)"},{"location":"cyberd/pipelines/","text":"General Chaingear/Database pipeline \u00b6 Database CRUD/tokenized Entry/Funds pipeline \u00b6 Chaingear tokenized Database pipeline \u00b6","title":"Pipelines"},{"location":"cyberd/pipelines/#general-chaingeardatabase-pipeline","text":"","title":"General Chaingear/Database pipeline"},{"location":"cyberd/pipelines/#database-crudtokenized-entryfunds-pipeline","text":"","title":"Database CRUD/tokenized Entry/Funds pipeline"},{"location":"cyberd/pipelines/#chaingear-tokenized-database-pipeline","text":"","title":"Chaingear tokenized Database pipeline"},{"location":"cyberd/help/development/","text":"Configuring, development and deploying \u00b6 Install \u00b6 npm i Linting: \u00b6 solium -d contracts Testing: \u00b6 ganache-cli -p 8545 truffle test Deploying (for example kovan): \u00b6 truffle migrate --network =","title":"Configuring, development and deploying"},{"location":"cyberd/help/development/#configuring-development-and-deploying","text":"","title":"Configuring, development and deploying"},{"location":"cyberd/help/development/#install","text":"npm i","title":"Install"},{"location":"cyberd/help/development/#linting","text":"solium -d contracts","title":"Linting:"},{"location":"cyberd/help/development/#testing","text":"ganache-cli -p 8545 truffle test","title":"Testing:"},{"location":"cyberd/help/development/#deploying-for-example-kovan","text":"truffle migrate --network =","title":"Deploying (for example kovan):"},{"location":"help/chaingear/1/","text":"","title":"chaingear"},{"location":"help/cyb/1/","text":"","title":"cyb"},{"location":"\u0441haingear/Changelog/","text":"Changelog \u00b6 All major changes of chaingear will be documented in this file. Sprint 9: \u00b6 1. Started frontend migration to new architecture (spring 9 - initialial relealse contracts's epic) 2. Changed architecture: - Splitting Registry creation in two stages - creation (in Chaingear) and post-initialization with EntryCore's bytecode (in Registry via admin/token holder) - Splitting Entry creation in two states - creation/deletion in Registry (with token minting/burning) and updating/reading in EntryCore 3. Improved policies: - Improved policies for Chaingear - Improved policies for Registry 3. Added advanced tests: - Improved and added more tests to Chaingear (Registry Creation, Chaingear Settings, policies) - Improved and added more tests to Registry (EntryCore initialization, CRUD, policies, Registry settings) 4. Initial gas estimation: - First meaningfull estimates of gas consumption for Chaingear creation, Registry creation, Registry initialization (with user generated EntryCore bytecode), Entry adding 5. Refactoring: - Policies refactoring 5. Improved documentation: - Improved NatSpec 6. Iceboxing after Research and Refactoring: - Funding of Chaingear registries - Funding of Registry entries Sprint 7-8: \u00b6 1. Initial frontend with Web3 and Metamask/Truffle integration 2. Created initial version of contract of Chaingear/Registry 3. Initial research/integration of ERC721 to tokenize registries/entries in Chaingear/Registry 4. Initial realization of policies for Chaingear/Registry 5. Initial research/realization of cross-linking Registries tokens in Chaingear with side Registries smart-contracts","title":"Changelog"},{"location":"\u0441haingear/Changelog/#changelog","text":"All major changes of chaingear will be documented in this file.","title":"Changelog"},{"location":"\u0441haingear/Changelog/#sprint-9","text":"1. Started frontend migration to new architecture (spring 9 - initialial relealse contracts's epic) 2. Changed architecture: - Splitting Registry creation in two stages - creation (in Chaingear) and post-initialization with EntryCore's bytecode (in Registry via admin/token holder) - Splitting Entry creation in two states - creation/deletion in Registry (with token minting/burning) and updating/reading in EntryCore 3. Improved policies: - Improved policies for Chaingear - Improved policies for Registry 3. Added advanced tests: - Improved and added more tests to Chaingear (Registry Creation, Chaingear Settings, policies) - Improved and added more tests to Registry (EntryCore initialization, CRUD, policies, Registry settings) 4. Initial gas estimation: - First meaningfull estimates of gas consumption for Chaingear creation, Registry creation, Registry initialization (with user generated EntryCore bytecode), Entry adding 5. Refactoring: - Policies refactoring 5. Improved documentation: - Improved NatSpec 6. Iceboxing after Research and Refactoring: - Funding of Chaingear registries - Funding of Registry entries","title":"Sprint 9:"},{"location":"\u0441haingear/Changelog/#sprint-7-8","text":"1. Initial frontend with Web3 and Metamask/Truffle integration 2. Created initial version of contract of Chaingear/Registry 3. Initial research/integration of ERC721 to tokenize registries/entries in Chaingear/Registry 4. Initial realization of policies for Chaingear/Registry 5. Initial research/realization of cross-linking Registries tokens in Chaingear with side Registries smart-contracts","title":"Sprint 7-8:"},{"location":"\u0441haingear/contracts/","text":"Contracts Overview \u00b6 Design rationale \u00b6 Main design principle goes from ERC721 NFT tokenization of Registries (in Chaingear/Metaregistry) and Entries (in custom Registry). In reason of Registries tokenization in Chaingear which allows token holder acts as administrator of their Registry, Chaingear acts to Registry as owner, which sets holder as administrator on creation phase, changes administrator when holder transfers token to another user, and transfers ownership when user unregister Registry in Chaingear, giving them full control to contract. Registry deep-linked to Chaingear registry token. In other words, token ownership means control of Registry. Also, Chaingear supports multiple Registry Creators (fabrics of registries), and allows Chaingear owners provide different kind and versioning of Registries. In reason of providing user functionality to describe their custom registry data structures and CRUD operations, the user creates their custom smart-contract, which implements the EntryInterface interface. This contract acts as inner storage, defines schema, and Registry acts them on token operations (creating and deleting). A user may deploy erroneous or vulnerable EntryCore contract, but this should not crash Chaingear-Registry NFT-token logic and Registry inner entry NFT-logic too. Even if this happens Registry crashing should not affect Chaingear/metaregistry contract. We proceed from the premise that the creator of the registry (administrator) is positive and it does not make sense for them to break his registry by initializing it with an incorrect contract. This brings us to tokenized ( C RU D ) operations (and inner private in EntryCore) in Registry-EntryCore and public ( C R UD ) actions/direct EntroCore tokenized ( CR U D ) operations. Chaingear inheritance \u00b6 Registry inheritance \u00b6 PS: OZ stands to Open Zeppelin contracts \u00b6 /chaingear \u00b6 Chaingear allows any user to create his own registry. Building fee is collecting by new registry creation. All builded registries are tokenized with ERC721 NFT token standard and saved in Chaingear metaregistry with registry metainformation. Creator of registry may transfer tokenized ownership of registry and destroy registry with token burning. Tokenized registries Entries may collect funds by users. Chaingear supports multiple benefitiaries witch have access to collected fees. ChaingearCore holds general logic of Chaingear. Allows change chaingear's metainformation, amount of registration fee, adding multiple registry creator contracts based on versioning or/and functionality. RegistryBase holds struct of data with describes registry metainformation which associated with token, views function for registry metainformation. RegistryCreator contains the code of specified version of Registry. This code used by Chaingear for Registry creation process. Registry Creator should be added with specified version and description to Chaingear Registry Creators inner registry. Chaingear contract should be added as builder to Registry Creator with reason to allow creation calls only by Chaingear contact. /common \u00b6 RegistySafe allows creator contract transfer ETHs to them and claim from, accounting logic holded by owner contract. SplitPaymentChangeable allows add beneficiaries to contract (addresses and shares amount) and change payee address. Beneficiaries can claim ETHs from contract proportionally to their shares. /registry \u00b6 Chaingeareable holds basic logic of Registry as registry basic information, balance and fees amount. Contains getters and setters for registry name, description, tags, entry base address. EntryInterface interface for EntryCore . Holds entry metainformation and interfaces of functions ( C RU D ) which should be implemented in EntryCore . Uses for interaction between Registry and EntryCore. EntryCore partially code-generated contract where registry creator setup their custom entry structure and setters/getters. EntryCore then initializes in Registry by their creator (as admin) and completes Registry setup process. Provides public ( C RU D ) actions for users and inner ( C RU D ) tokenized actions for Registry. Registry goes as owner of contract (and acts as proxy) with entries creating, token-based transferring and deleting. Registry contract witch tokenize entries as NFT tokens via ERC721 standard. Users can create tokenized empty entries according to entry access policy setted in Registry. Registry provides tokenized ( C RU D ) actions, after creation of token and empty registry object, user should initialize them in EntryCore. Also users can fund entries with ETHs which send to RegistrySafe where owner of entry token can claim funds. RegistryAccessControl holds logic of controlling registry and accessing to entries creation. Policy options to entries creation are OnlyAdministrator, AllUsers. Chaingear acts as owner of Registry and creator of registry acts of administrator with separated policies to Registry functions. EntryInterface interface (should be implemented in user EntryCore contract) \u00b6 contract EntryInterface { function entriesAmount () external view returns ( uint256 ); function createEntry () external returns ( uint256 ); function deleteEntry ( uint256 ) external ; } Example EntryCore (with example custom structure and required functions) \u00b6 pragma solidity 0.4.24 ; import \"../common/EntryInterface.sol\" ; import \"openzeppelin-solidity/contracts/ownership/Ownable.sol\" ; //This is Example of EntryCore contract EntryCore is EntryInterface , Ownable { struct Entry { address expensiveAddress ; uint256 expensiveUint ; int128 expensiveInt ; string expensiveString ; } mapping ( string => bool ) internal entryExpensiveStringIndex ; Entry [] internal entries ; function () external {} function createEntry () external onlyOwner returns ( uint256 ) { Entry memory m = ( Entry ( { expensiveAddress : address ( 0 ), expensiveUint : uint256 ( 0 ), expensiveInt : int128 ( 0 ), expensiveString : \"\" })); uint256 newEntryID = entries . push ( m ) - 1 ; return newEntryID ; } function updateEntry ( uint256 _entryID , address _newAddress , uint256 _newUint , int128 _newInt , string _newString ) external { require ( owner . call ( bytes4 ( keccak256 ( \"checkAuth(uint256, address)\" )), _entryID , msg . sender )); // for uniq check example require ( entryExpensiveStringIndex [ _newString ] == false ); Entry memory m = ( Entry ({ expensiveAddress : _newAddress , expensiveUint : _newUint , expensiveInt : _newInt , expensiveString : _newString })); entries [ _entryID ] = m ; // for uniq check example entryExpensiveStringIndex [ _newString ] = true ; require ( owner . call ( bytes4 ( keccak256 ( \"updateEntryTimestamp(uint256)\" )), _entryID )); } function deleteEntry ( uint256 _entryIndex ) external onlyOwner { uint256 lastEntryIndex = entries . length - 1 ; Entry storage lastEntry = entries [ lastEntryIndex ]; entries [ _entryIndex ] = lastEntry ; delete entries [ lastEntryIndex ]; entries . length -- ; } function entriesAmount () external view returns ( uint256 entryID ) { return entries . length ; } function entryInfo ( uint256 _entryID ) external view returns ( address , uint256 , int128 , string ) { return ( entries [ _entryID ]. expensiveAddress , entries [ _entryID ]. expensiveUint , entries [ _entryID ]. expensiveInt , entries [ _entryID ]. expensiveString ); } }","title":"Contracts"},{"location":"\u0441haingear/contracts/#contracts-overview","text":"","title":"Contracts Overview"},{"location":"\u0441haingear/contracts/#design-rationale","text":"Main design principle goes from ERC721 NFT tokenization of Registries (in Chaingear/Metaregistry) and Entries (in custom Registry). In reason of Registries tokenization in Chaingear which allows token holder acts as administrator of their Registry, Chaingear acts to Registry as owner, which sets holder as administrator on creation phase, changes administrator when holder transfers token to another user, and transfers ownership when user unregister Registry in Chaingear, giving them full control to contract. Registry deep-linked to Chaingear registry token. In other words, token ownership means control of Registry. Also, Chaingear supports multiple Registry Creators (fabrics of registries), and allows Chaingear owners provide different kind and versioning of Registries. In reason of providing user functionality to describe their custom registry data structures and CRUD operations, the user creates their custom smart-contract, which implements the EntryInterface interface. This contract acts as inner storage, defines schema, and Registry acts them on token operations (creating and deleting). A user may deploy erroneous or vulnerable EntryCore contract, but this should not crash Chaingear-Registry NFT-token logic and Registry inner entry NFT-logic too. Even if this happens Registry crashing should not affect Chaingear/metaregistry contract. We proceed from the premise that the creator of the registry (administrator) is positive and it does not make sense for them to break his registry by initializing it with an incorrect contract. This brings us to tokenized ( C RU D ) operations (and inner private in EntryCore) in Registry-EntryCore and public ( C R UD ) actions/direct EntroCore tokenized ( CR U D ) operations.","title":"Design rationale"},{"location":"\u0441haingear/contracts/#chaingear-inheritance","text":"","title":"Chaingear inheritance"},{"location":"\u0441haingear/contracts/#registry-inheritance","text":"","title":"Registry inheritance"},{"location":"\u0441haingear/contracts/#ps-oz-stands-to-open-zeppelin-contracts","text":"","title":"PS: OZ stands to Open Zeppelin contracts"},{"location":"\u0441haingear/contracts/#chaingear","text":"Chaingear allows any user to create his own registry. Building fee is collecting by new registry creation. All builded registries are tokenized with ERC721 NFT token standard and saved in Chaingear metaregistry with registry metainformation. Creator of registry may transfer tokenized ownership of registry and destroy registry with token burning. Tokenized registries Entries may collect funds by users. Chaingear supports multiple benefitiaries witch have access to collected fees. ChaingearCore holds general logic of Chaingear. Allows change chaingear's metainformation, amount of registration fee, adding multiple registry creator contracts based on versioning or/and functionality. RegistryBase holds struct of data with describes registry metainformation which associated with token, views function for registry metainformation. RegistryCreator contains the code of specified version of Registry. This code used by Chaingear for Registry creation process. Registry Creator should be added with specified version and description to Chaingear Registry Creators inner registry. Chaingear contract should be added as builder to Registry Creator with reason to allow creation calls only by Chaingear contact.","title":"/chaingear"},{"location":"\u0441haingear/contracts/#common","text":"RegistySafe allows creator contract transfer ETHs to them and claim from, accounting logic holded by owner contract. SplitPaymentChangeable allows add beneficiaries to contract (addresses and shares amount) and change payee address. Beneficiaries can claim ETHs from contract proportionally to their shares.","title":"/common"},{"location":"\u0441haingear/contracts/#registry","text":"Chaingeareable holds basic logic of Registry as registry basic information, balance and fees amount. Contains getters and setters for registry name, description, tags, entry base address. EntryInterface interface for EntryCore . Holds entry metainformation and interfaces of functions ( C RU D ) which should be implemented in EntryCore . Uses for interaction between Registry and EntryCore. EntryCore partially code-generated contract where registry creator setup their custom entry structure and setters/getters. EntryCore then initializes in Registry by their creator (as admin) and completes Registry setup process. Provides public ( C RU D ) actions for users and inner ( C RU D ) tokenized actions for Registry. Registry goes as owner of contract (and acts as proxy) with entries creating, token-based transferring and deleting. Registry contract witch tokenize entries as NFT tokens via ERC721 standard. Users can create tokenized empty entries according to entry access policy setted in Registry. Registry provides tokenized ( C RU D ) actions, after creation of token and empty registry object, user should initialize them in EntryCore. Also users can fund entries with ETHs which send to RegistrySafe where owner of entry token can claim funds. RegistryAccessControl holds logic of controlling registry and accessing to entries creation. Policy options to entries creation are OnlyAdministrator, AllUsers. Chaingear acts as owner of Registry and creator of registry acts of administrator with separated policies to Registry functions.","title":"/registry"},{"location":"\u0441haingear/contracts/#entryinterface-interface-should-be-implemented-in-user-entrycore-contract","text":"contract EntryInterface { function entriesAmount () external view returns ( uint256 ); function createEntry () external returns ( uint256 ); function deleteEntry ( uint256 ) external ; }","title":"EntryInterface interface (should be implemented in user EntryCore contract)"},{"location":"\u0441haingear/contracts/#example-entrycore-with-example-custom-structure-and-required-functions","text":"pragma solidity 0.4.24 ; import \"../common/EntryInterface.sol\" ; import \"openzeppelin-solidity/contracts/ownership/Ownable.sol\" ; //This is Example of EntryCore contract EntryCore is EntryInterface , Ownable { struct Entry { address expensiveAddress ; uint256 expensiveUint ; int128 expensiveInt ; string expensiveString ; } mapping ( string => bool ) internal entryExpensiveStringIndex ; Entry [] internal entries ; function () external {} function createEntry () external onlyOwner returns ( uint256 ) { Entry memory m = ( Entry ( { expensiveAddress : address ( 0 ), expensiveUint : uint256 ( 0 ), expensiveInt : int128 ( 0 ), expensiveString : \"\" })); uint256 newEntryID = entries . push ( m ) - 1 ; return newEntryID ; } function updateEntry ( uint256 _entryID , address _newAddress , uint256 _newUint , int128 _newInt , string _newString ) external { require ( owner . call ( bytes4 ( keccak256 ( \"checkAuth(uint256, address)\" )), _entryID , msg . sender )); // for uniq check example require ( entryExpensiveStringIndex [ _newString ] == false ); Entry memory m = ( Entry ({ expensiveAddress : _newAddress , expensiveUint : _newUint , expensiveInt : _newInt , expensiveString : _newString })); entries [ _entryID ] = m ; // for uniq check example entryExpensiveStringIndex [ _newString ] = true ; require ( owner . call ( bytes4 ( keccak256 ( \"updateEntryTimestamp(uint256)\" )), _entryID )); } function deleteEntry ( uint256 _entryIndex ) external onlyOwner { uint256 lastEntryIndex = entries . length - 1 ; Entry storage lastEntry = entries [ lastEntryIndex ]; entries [ _entryIndex ] = lastEntry ; delete entries [ lastEntryIndex ]; entries . length -- ; } function entriesAmount () external view returns ( uint256 entryID ) { return entries . length ; } function entryInfo ( uint256 _entryID ) external view returns ( address , uint256 , int128 , string ) { return ( entries [ _entryID ]. expensiveAddress , entries [ _entryID ]. expensiveUint , entries [ _entryID ]. expensiveInt , entries [ _entryID ]. expensiveString ); } }","title":"Example EntryCore (with example custom structure and required functions)"},{"location":"\u0441haingear/development/","text":"Configuring, development and deploying \u00b6 Development environment \u00b6 Recommending to use Remix Ethereum Online IDE or desktop electron-based Remix IDE PS: to import to IDE open-zeppelin contacts change imports this way: import \"github.com/openZeppelin/zeppelin-solidity/contracts/ownership/Ownable.sol\" ; Truffle + Ganache workflow \u00b6 Install Ganache (with UI) from latest release or npm package => npm install -g ganache-cli Configure development config in truffle.js and launch Ganache (configure them too if needed) and: ganache-cli -p 7545 ( in first tab/or run UI-client ) truffle migrate --network development --reset ( in second tab ) truffle console --network development ( in second tab ) Creating new registry/CRU entries (truffle console way/no Remix IDE) \u00b6 var chaingear = Chaingear.at ( Chaingear.address ) var beneficiaries = [] var shares = [] var buildingFee = 100000 var gas = 10000000 chaingear.registerRegistry ( \"V1\" , beneficiaries, shares, \"BlockchainRegistry\" , \"BLR\" , { value: 100000 , gas: 10000000 }) var registryAddress = chaingear.registryInfo.call ( 0 ) var registry = Registry.at ( 'insert_registry_address_here' ) registry.initializeRegistry ( \"IPFS_HASH\" , EntryCore.bytecode ) registry.createEntry () var entryCoreAddress = registry.getEntriesStorage () var entryCore = EntryCore.at ( 'insert_entry_core_address_here' ) entryCore.updateEntry ( 0 , '0xa2f0dde51cb715f9cc7c12763fef90270bd50f70' , 256 , -127, \"helloworld\" ) entryCore.entryInfo ( 0 ) // --->>> [ '0xa2f0dde51cb715f9cc7c12763fef90270bd50f70' , BigNumber { s: 1 , e: 2 , c: [ 256 ] } , BigNumber { s: -1, e: 2 , c: [ 127 ] } , 'helloworld' ] Linting: \u00b6 npm install -g solium solium -d contracts Testing: \u00b6 truffle test PS: script will run separate tests flow for each file, also produce gas report. Temp solution, for while we don't fix problem with tests falls when running for all files at one time what in truffle by default. Deploying (for example kovan): \u00b6 parity ui --chain = kovan truffle migrate --network = kovan PS: approve transaction in parity ui ( http://127.0.0.1:8180/ ) (Optional) Build contract in file: \u00b6 truffle-flattener contracts/registry/Registry.sol > Registry_full.sol","title":"Development"},{"location":"\u0441haingear/development/#configuring-development-and-deploying","text":"","title":"Configuring, development and deploying"},{"location":"\u0441haingear/development/#development-environment","text":"Recommending to use Remix Ethereum Online IDE or desktop electron-based Remix IDE PS: to import to IDE open-zeppelin contacts change imports this way: import \"github.com/openZeppelin/zeppelin-solidity/contracts/ownership/Ownable.sol\" ;","title":"Development environment"},{"location":"\u0441haingear/development/#truffle-ganache-workflow","text":"Install Ganache (with UI) from latest release or npm package => npm install -g ganache-cli Configure development config in truffle.js and launch Ganache (configure them too if needed) and: ganache-cli -p 7545 ( in first tab/or run UI-client ) truffle migrate --network development --reset ( in second tab ) truffle console --network development ( in second tab )","title":"Truffle + Ganache workflow"},{"location":"\u0441haingear/development/#creating-new-registrycru-entries-truffle-console-wayno-remix-ide","text":"var chaingear = Chaingear.at ( Chaingear.address ) var beneficiaries = [] var shares = [] var buildingFee = 100000 var gas = 10000000 chaingear.registerRegistry ( \"V1\" , beneficiaries, shares, \"BlockchainRegistry\" , \"BLR\" , { value: 100000 , gas: 10000000 }) var registryAddress = chaingear.registryInfo.call ( 0 ) var registry = Registry.at ( 'insert_registry_address_here' ) registry.initializeRegistry ( \"IPFS_HASH\" , EntryCore.bytecode ) registry.createEntry () var entryCoreAddress = registry.getEntriesStorage () var entryCore = EntryCore.at ( 'insert_entry_core_address_here' ) entryCore.updateEntry ( 0 , '0xa2f0dde51cb715f9cc7c12763fef90270bd50f70' , 256 , -127, \"helloworld\" ) entryCore.entryInfo ( 0 ) // --->>> [ '0xa2f0dde51cb715f9cc7c12763fef90270bd50f70' , BigNumber { s: 1 , e: 2 , c: [ 256 ] } , BigNumber { s: -1, e: 2 , c: [ 127 ] } , 'helloworld' ]","title":"Creating new registry/CRU entries (truffle console way/no Remix IDE)"},{"location":"\u0441haingear/development/#linting","text":"npm install -g solium solium -d contracts","title":"Linting:"},{"location":"\u0441haingear/development/#testing","text":"truffle test PS: script will run separate tests flow for each file, also produce gas report. Temp solution, for while we don't fix problem with tests falls when running for all files at one time what in truffle by default.","title":"Testing:"},{"location":"\u0441haingear/development/#deploying-for-example-kovan","text":"parity ui --chain = kovan truffle migrate --network = kovan PS: approve transaction in parity ui ( http://127.0.0.1:8180/ )","title":"Deploying (for example kovan):"},{"location":"\u0441haingear/development/#optional-build-contract-in-file","text":"truffle-flattener contracts/registry/Registry.sol > Registry_full.sol","title":"(Optional) Build contract in file:"},{"location":"\u0441haingear/overview/","text":"Overview \u00b6 This project allows you to create your own Registry of general purpose entries on Ethereum blockchain. Entry type is defined during creation, so you can put into entry any custom logic you want (validation, entry-level permission control). Entries are tokenized as NFT. Your creating your registry in Chaingear - metaregistry, which are one point of access to all registries. Registries on chaingear level are tokenized as NFT. Chaingear is most expensive registry, so you should pay for your registry creation. Features \u00b6 Chaingear \u00b6 Metaregistry with Registries entries, where each entry are ERC721 token Fee-based Registry creation Creating Registries with different functionality Token-based ownership/administration for Registry Funding in ETH for Registries Custom registry \u00b6 Custom data structure for Registry (EntryCore) Each Entry is ERC721 token Fee-based Entry creation Token-based ownership Entry management Entry creation policies (Administrator, Whitelist, AllUsers) Chaingear UI (browser/stand-alone web3 DApp) \u00b6 Web3/Metamask/Truffle/IPFS based Full Chaingear control interface Full custom Registry control interface Simple smart-contract EntryCore code generation in client Registries ABI and metainformation savings in IPFS","title":"Overview"},{"location":"\u0441haingear/overview/#overview","text":"This project allows you to create your own Registry of general purpose entries on Ethereum blockchain. Entry type is defined during creation, so you can put into entry any custom logic you want (validation, entry-level permission control). Entries are tokenized as NFT. Your creating your registry in Chaingear - metaregistry, which are one point of access to all registries. Registries on chaingear level are tokenized as NFT. Chaingear is most expensive registry, so you should pay for your registry creation.","title":"Overview"},{"location":"\u0441haingear/overview/#features","text":"","title":"Features"},{"location":"\u0441haingear/overview/#chaingear","text":"Metaregistry with Registries entries, where each entry are ERC721 token Fee-based Registry creation Creating Registries with different functionality Token-based ownership/administration for Registry Funding in ETH for Registries","title":"Chaingear"},{"location":"\u0441haingear/overview/#custom-registry","text":"Custom data structure for Registry (EntryCore) Each Entry is ERC721 token Fee-based Entry creation Token-based ownership Entry management Entry creation policies (Administrator, Whitelist, AllUsers)","title":"Custom registry"},{"location":"\u0441haingear/overview/#chaingear-ui-browserstand-alone-web3-dapp","text":"Web3/Metamask/Truffle/IPFS based Full Chaingear control interface Full custom Registry control interface Simple smart-contract EntryCore code generation in client Registries ABI and metainformation savings in IPFS","title":"Chaingear UI (browser/stand-alone web3 DApp)"},{"location":"\u0441haingear/pipelines/","text":"General Chaingear/Registry pipeline \u00b6 Registry CRUD/tokenized Entry/Funds pipeline \u00b6 Chaingear tokenized Registries pipeline \u00b6","title":"Pipelines"},{"location":"\u0441haingear/pipelines/#general-chaingearregistry-pipeline","text":"","title":"General Chaingear/Registry pipeline"},{"location":"\u0441haingear/pipelines/#registry-crudtokenized-entryfunds-pipeline","text":"","title":"Registry CRUD/tokenized Entry/Funds pipeline"},{"location":"\u0441haingear/pipelines/#chaingear-tokenized-registries-pipeline","text":"","title":"Chaingear tokenized Registries pipeline"}]}